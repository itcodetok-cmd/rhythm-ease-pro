


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE SCHEMA IF NOT EXISTS "public";


ALTER SCHEMA "public" OWNER TO "pg_database_owner";


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE OR REPLACE FUNCTION "public"."get_invoices_for_reminder"() RETURNS TABLE("invoice_id" bigint, "student_id" bigint, "amount" numeric, "days_pending" integer)
    LANGUAGE "plpgsql"
    AS $$
begin
  return query
  select
    invoice_id,
    student_id,
    amount,
    days_pending
  from pending_invoices
  where
    days_pending >= 15
    and (
      days_pending = 15
      or (days_pending > 15 and (days_pending - 15) % 2 = 0)
    );
end;
$$;


ALTER FUNCTION "public"."get_invoices_for_reminder"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."on_class_conducted"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  if new.is_conducted = true then

    -- ðŸ”¹ Batch class
    if new.batch_id is not null then
      perform process_class_session(new.batch_id);
    end if;

    -- ðŸ”¹ Single class
    if new.student_id is not null then
      perform process_single_class(new.student_id);
    end if;

  end if;

  return new;
end;
$$;


ALTER FUNCTION "public"."on_class_conducted"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_class_session"("p_batch_id" bigint) RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
declare
  s record;
begin
  for s in
    select id, fee_amount
    from students
    where batch_id = p_batch_id
      and is_active = true
  loop
    insert into student_class_counter (student_id, class_count)
    values (s.id, 1)
    on conflict (student_id)
    do update set class_count = student_class_counter.class_count + 1;

    if (select class_count from student_class_counter where student_id = s.id) >= 4 then
      insert into invoices (student_id, amount, status)
      values (s.id, s.fee_amount, 'unpaid');

      update student_class_counter
      set class_count = 0
      where student_id = s.id;
    end if;
  end loop;
end;
$$;


ALTER FUNCTION "public"."process_class_session"("p_batch_id" bigint) OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_payment_reminders"() RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
declare
  r record;
begin
  for r in
    select * from (
      select
        i.id as invoice_id,
        i.student_id,
        i.amount,
        current_date - i.generated_on as days_pending
      from invoices i
      where i.is_paid = false
    ) pending
    where
      days_pending >= 15
      and (
        days_pending = 15
        or (days_pending > 15 and (days_pending - 15) % 2 = 0)
      )
  loop
    if not exists (
      select 1 from reminder_logs
      where invoice_id = r.invoice_id
        and sent_on = current_date
    ) then
      insert into reminder_logs (invoice_id, channel)
      values (r.invoice_id, 'email');
    end if;
  end loop;
end;
$$;


ALTER FUNCTION "public"."process_payment_reminders"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."process_single_class"("p_student_id" bigint) RETURNS "void"
    LANGUAGE "plpgsql"
    AS $$
declare
  fee numeric;
  count int;
begin
  select fee_amount into fee
  from students
  where id = p_student_id
    and is_active = true;

  if fee is null then
    return;
  end if;

  insert into student_class_counter (student_id, class_count)
  values (p_student_id, 1)
  on conflict (student_id)
  do update set class_count = student_class_counter.class_count + 1;

  select class_count into count
  from student_class_counter
  where student_id = p_student_id;

  if count >= 4 then
    insert into invoices (student_id, amount, status)
    values (p_student_id, fee, 'unpaid');

    update student_class_counter
    set class_count = 0
    where student_id = p_student_id;
  end if;
end;
$$;


ALTER FUNCTION "public"."process_single_class"("p_student_id" bigint) OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."batches" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text" NOT NULL,
    "days" "text"[] NOT NULL,
    "start_time" time without time zone NOT NULL,
    "end_time" time without time zone NOT NULL
);


ALTER TABLE "public"."batches" OWNER TO "postgres";


ALTER TABLE "public"."batches" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."batches_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."class_sessions" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "batch_id" bigint,
    "conducted_on" "date" NOT NULL,
    "is_conducted" boolean DEFAULT true,
    "student_id" bigint
);


ALTER TABLE "public"."class_sessions" OWNER TO "postgres";


ALTER TABLE "public"."class_sessions" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."class_sessions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."invoices" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "student_id" bigint NOT NULL,
    "amount" numeric NOT NULL,
    "generated_on" "date" DEFAULT CURRENT_DATE,
    "due_date" "date",
    "is_paid" boolean DEFAULT false
);


ALTER TABLE "public"."invoices" OWNER TO "postgres";


ALTER TABLE "public"."invoices" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."invoices_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."payments" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "invoice_id" bigint NOT NULL,
    "amount" numeric NOT NULL,
    "paid_on" "date" DEFAULT CURRENT_DATE,
    "method" "text"
);


ALTER TABLE "public"."payments" OWNER TO "postgres";


ALTER TABLE "public"."payments" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."payments_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE OR REPLACE VIEW "public"."pending_invoices" AS
 SELECT "id" AS "invoice_id",
    "student_id",
    "amount",
    "generated_on",
    (CURRENT_DATE - "generated_on") AS "days_pending"
   FROM "public"."invoices" "i"
  WHERE ("is_paid" = false);


ALTER VIEW "public"."pending_invoices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."reminder_logs" (
    "id" bigint NOT NULL,
    "invoice_id" bigint NOT NULL,
    "sent_on" "date" DEFAULT CURRENT_DATE,
    "channel" "text" NOT NULL
);


ALTER TABLE "public"."reminder_logs" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."reminder_logs_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER SEQUENCE "public"."reminder_logs_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."reminder_logs_id_seq" OWNED BY "public"."reminder_logs"."id";



CREATE TABLE IF NOT EXISTS "public"."student_class_counter" (
    "student_id" bigint NOT NULL,
    "class_count" integer DEFAULT 0
);


ALTER TABLE "public"."student_class_counter" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."students" (
    "id" bigint NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "name" "text" NOT NULL,
    "email" "text",
    "phone" "text",
    "fee_amount" numeric NOT NULL,
    "batch_id" bigint,
    "is_active" boolean DEFAULT true
);


ALTER TABLE "public"."students" OWNER TO "postgres";


ALTER TABLE "public"."students" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."students_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



ALTER TABLE ONLY "public"."reminder_logs" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."reminder_logs_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."batches"
    ADD CONSTRAINT "batches_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."class_sessions"
    ADD CONSTRAINT "class_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "invoices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "payments_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."reminder_logs"
    ADD CONSTRAINT "reminder_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."student_class_counter"
    ADD CONSTRAINT "student_class_counter_pkey" PRIMARY KEY ("student_id");



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "students_pkey" PRIMARY KEY ("id");



CREATE OR REPLACE TRIGGER "trg_class_conducted" AFTER INSERT ON "public"."class_sessions" FOR EACH ROW EXECUTE FUNCTION "public"."on_class_conducted"();



ALTER TABLE ONLY "public"."student_class_counter"
    ADD CONSTRAINT "fk_counter_student" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."invoices"
    ADD CONSTRAINT "fk_invoices_student" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."payments"
    ADD CONSTRAINT "fk_payments_invoice" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."reminder_logs"
    ADD CONSTRAINT "fk_reminder_invoice" FOREIGN KEY ("invoice_id") REFERENCES "public"."invoices"("id");



ALTER TABLE ONLY "public"."class_sessions"
    ADD CONSTRAINT "fk_sessions_batch" FOREIGN KEY ("batch_id") REFERENCES "public"."batches"("id");



ALTER TABLE ONLY "public"."class_sessions"
    ADD CONSTRAINT "fk_sessions_student" FOREIGN KEY ("student_id") REFERENCES "public"."students"("id");



ALTER TABLE ONLY "public"."students"
    ADD CONSTRAINT "fk_students_batch" FOREIGN KEY ("batch_id") REFERENCES "public"."batches"("id");



ALTER TABLE "public"."batches" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."class_sessions" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."invoices" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."payments" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."students" ENABLE ROW LEVEL SECURITY;


GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



GRANT ALL ON FUNCTION "public"."get_invoices_for_reminder"() TO "anon";
GRANT ALL ON FUNCTION "public"."get_invoices_for_reminder"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."get_invoices_for_reminder"() TO "service_role";



GRANT ALL ON FUNCTION "public"."on_class_conducted"() TO "anon";
GRANT ALL ON FUNCTION "public"."on_class_conducted"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."on_class_conducted"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_class_session"("p_batch_id" bigint) TO "anon";
GRANT ALL ON FUNCTION "public"."process_class_session"("p_batch_id" bigint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_class_session"("p_batch_id" bigint) TO "service_role";



GRANT ALL ON FUNCTION "public"."process_payment_reminders"() TO "anon";
GRANT ALL ON FUNCTION "public"."process_payment_reminders"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_payment_reminders"() TO "service_role";



GRANT ALL ON FUNCTION "public"."process_single_class"("p_student_id" bigint) TO "anon";
GRANT ALL ON FUNCTION "public"."process_single_class"("p_student_id" bigint) TO "authenticated";
GRANT ALL ON FUNCTION "public"."process_single_class"("p_student_id" bigint) TO "service_role";



GRANT ALL ON TABLE "public"."batches" TO "anon";
GRANT ALL ON TABLE "public"."batches" TO "authenticated";
GRANT ALL ON TABLE "public"."batches" TO "service_role";



GRANT ALL ON SEQUENCE "public"."batches_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."batches_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."batches_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."class_sessions" TO "anon";
GRANT ALL ON TABLE "public"."class_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."class_sessions" TO "service_role";



GRANT ALL ON SEQUENCE "public"."class_sessions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."class_sessions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."class_sessions_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."invoices" TO "anon";
GRANT ALL ON TABLE "public"."invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."invoices" TO "service_role";



GRANT ALL ON SEQUENCE "public"."invoices_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."invoices_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."invoices_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."payments" TO "anon";
GRANT ALL ON TABLE "public"."payments" TO "authenticated";
GRANT ALL ON TABLE "public"."payments" TO "service_role";



GRANT ALL ON SEQUENCE "public"."payments_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."payments_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."payments_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."pending_invoices" TO "anon";
GRANT ALL ON TABLE "public"."pending_invoices" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_invoices" TO "service_role";



GRANT ALL ON TABLE "public"."reminder_logs" TO "anon";
GRANT ALL ON TABLE "public"."reminder_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."reminder_logs" TO "service_role";



GRANT ALL ON SEQUENCE "public"."reminder_logs_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."reminder_logs_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."reminder_logs_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."student_class_counter" TO "anon";
GRANT ALL ON TABLE "public"."student_class_counter" TO "authenticated";
GRANT ALL ON TABLE "public"."student_class_counter" TO "service_role";



GRANT ALL ON TABLE "public"."students" TO "anon";
GRANT ALL ON TABLE "public"."students" TO "authenticated";
GRANT ALL ON TABLE "public"."students" TO "service_role";



GRANT ALL ON SEQUENCE "public"."students_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."students_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."students_id_seq" TO "service_role";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES TO "service_role";







